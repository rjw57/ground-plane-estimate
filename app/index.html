<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraph.css" />
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <div id="image-ui"></div>
    <div id="floor-preview"></div>

<script type="x-shader/vertex" id="previewVertexShader">
varying vec2 floorCoord;

// vector giving [left, top, right, bottom] co-ords.
uniform vec4 viewBounds;
void main() {
    vec4 modelPosition = modelMatrix * vec4(position, 1.0);
    floorCoord = uv * (viewBounds.zy - viewBounds.xw);
    floorCoord += viewBounds.xw;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/fragment" id="previewFragmentShader">
varying vec2 floorCoord;

uniform vec2 textureSize;
uniform sampler2D image;
// Barrel/pincushion distortion coefficient.
// See https://en.wikipedia.org/wiki/Distortion_(optics)
uniform float barrelPercent;
uniform mat3 floorToImageMatrix;
uniform float floorRadius;

vec2 undistortImgToDistortImg(vec2 coord) {
    // convert co-ordinate to 0,0 == centre
    // convert co-ordinate to x in range [-1, 1]
    coord -= 0.5 * textureSize;
    coord /= 0.5 * textureSize.x;

    // scale coord
    float r2 = dot(coord, coord);
    coord *= (1.0 + 1e-2 * barrelPercent * r2);

    // convert back
    coord *= 0.5 * textureSize.x;
    coord += 0.5 * textureSize;

    return coord;
}

void main() {
    vec3 imgCoordHomog = floorToImageMatrix * vec3(floorCoord, 1.0);
    vec2 imgCoord = imgCoordHomog.xy / imgCoordHomog.z;

    // Correct distortion
    vec2 texCoord = imgCoord / textureSize;
    vec2 distTexCoord = undistortImgToDistortImg(imgCoord) / textureSize;

    float alpha = 1.0 - smoothstep(0.8 * floorRadius, 1.2 * floorRadius,
        length(floorCoord));

    // Clip to image
    if((imgCoordHomog.z > 0.0) && (texCoord.x >= 0.0) && (texCoord.y >= 0.0)
            && (texCoord.x < 1.0) && (texCoord.y < 1.0)) {
        gl_FragColor = alpha * texture2D(image, distTexCoord)
            + (1.0 - alpha) * vec4(0.0, 0.0, 0.0, 0.0);
    } else{
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    }
}
</script>

<!-- HACK: place GLSL code here for extraction. -->
<script type="x-shader/vertex" id="imageVertexShader">
varying vec2 imgCoord;
uniform vec2 textureSize;

void main() {
    imgCoord = uv * textureSize;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/fragment" id="imageFragmentShader">
varying vec2 imgCoord;

uniform vec2 textureSize;
uniform sampler2D image;

// Barrel/pincushion distortion coefficient.
// See https://en.wikipedia.org/wiki/Distortion_(optics)
uniform float barrelPercent;

vec2 undistortImgToDistortImg(vec2 coord) {
    // convert co-ordinate to 0,0 == centre
    coord -= 0.5 * textureSize;

    // convert co-ordinate to x in range [-1, 1]
    coord /= 0.5 * textureSize.x;

    // scale coord
    float r2 = dot(coord, coord);
    coord *= (1.0 + 1e-2 * barrelPercent * r2);

    // convert back
    coord *= 0.5 * textureSize.x;
    coord += 0.5 * textureSize;

    return coord;
}

void main() {
    vec2 distortImgCoord = undistortImgToDistortImg(imgCoord);
    gl_FragColor = texture2D(image, distortImgCoord / textureSize);
}
</script>

<script type="x-shader/vertex" id="floorVertexShader">
varying vec3 imageCoordHomog;
void main() {
    vec4 modelPosition = modelMatrix * vec4(position, 1.0);
    imageCoordHomog = vec3(modelPosition.xy, modelPosition.w);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/fragment" id="floorFragmentShader">
// #extension GL_OES_standard_derivatives : enable

varying vec3 imageCoordHomog;
uniform mat3 floorMatrix;
uniform float floorOpacity, floorRadius;

void main() {
    vec3 floorCoordHomog = floorMatrix * imageCoordHomog;
    if(floorCoordHomog.z <= 0.0) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    } else {
        float floorBrightness = 0.5;

        vec2 floorCoord = floorCoordHomog.xy / floorCoordHomog.z;
        float floorRad = length(floorCoord);

        // want 1x1m checkerboard
        vec2 floorFrac = fract(0.5 * floorCoord) - 0.5;
        float checkerQuad = floorFrac.x * floorFrac.y;
        floorBrightness = sign(checkerQuad);

        float alpha = floorOpacity *
            (1.0 - smoothstep(0.8 * floorRadius, 1.2 * floorRadius, floorRad));
        gl_FragColor = vec4(vec3(1.0, 1.0, 1.0) * floorBrightness, alpha);
    }
}
</script>

    <script src="http://jsxgraph.uni-bayreuth.de/distrib/jsxgraphcore.js"></script>
    <script src="http://www.numericjs.com/lib/numeric-1.2.6.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r73/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js"></script>
    <script src="FileSaver.min.js"></script>
    <script src="app.js"></script>
</body>

</html>
